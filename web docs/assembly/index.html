<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ANC16 Assembly</title>
	<link rel="stylesheet" href="../common/style.css">
	<script src="scr.js"></script>
	<script src="../common/common.js" defer></script>
</head>

<body>
	<nav>
		<div id="tab">
			<h1>ANC16 docs</h1>
			<h2 class="interactive" onclick="goto('../')">Doc</h2>
			<h2 class="interactive selected">Assembly</h2>
			<h2 class="interactive" onclick="goto('../assembler/index.html')">Assembler</h2>
			<h2 class="interactive" onclick="goto('../emulator/index.html')">Emulator</h2>
		</div>
		<div id="options">
			<h2>Theme</h2>
			<select class="interactive" id="theme">
				<option value="light">Light</option>
				<option value="dark">Dark</option>
			</select>
		</div>
	</nav>
	<div id="title">
		<h1>Assembly</h1>
	</div>
	<main>
		<h1>Introduction</h1>
		<p>
			In this section, we will list all the guidelines for writing in ANC16 assembly. But first, what is assembly?
			<br>
			The assembly language is a very low level language very similar to the machine language of the CPU in a
			computer.
			<br>
			Every architecture has a different assembly language. ANC16 assembly is different from x86 assembly.
		</p>
		<h1>ANC16 assembly standards</h1>
		<p>
			How to write in ANC16 assembly?
			<br>
			Before starting it is necessary to have a thorough knowledge of the ANC 16 architecture.
			<br>
			Registers, how the memory is organized and how to refer to a cell in memory are things to know very well.
			<br>
			You can check our official documentation.
		</p>
		<h2>Numbers</h2>
		<p>
			Usually, in computer science, different number bases.
			<br>
			You have to specify the number base when you are writing a number in assembly.
		</p>
		<ul>
			<li><strong>Base 10</strong>: just write the number normally, like <code>590</code></li>
			<li><strong>Base 16</strong>: you must put an <code>0x</code> before the number such as <code>0x24E</code>
				or <code>0x24e</code></li>
			<li><strong>Base 2</strong>: you have to write <code>0b</code> before the number: <code>0b1001001110</code>
			</li>
			<li><strong>Base 8</strong>: you have to write <code>0o</code> before the number: <code>0o1116</code></li>
		</ul>
		<h2>Addressing modes</h2>
		<p>
			As you know, there are many different addressing modes.
			<br>
			When we talk about addressing mode we talk about how to refer to a cell in memory.
			<br>
			In the ANC16 architecture there are 10 addressing modes:
		</p>
		<ul>
			<li>
				<strong>Absolute</strong>: the argument of the instruction is a word (16-bit) and is the address of a
				cell in memory.
				<br>
				To specify the absolute addressing mode, you just have to write the address, example:
				<code class="anc16">
					READ 0xFF00
				</code>
				or
				<code class="anc16">
					JMP 493
				</code>
			</li>
			<li>
				<strong>Absolute indexed</strong>: the argument of the instruction is a word (16-bit) and is the address
				+ the value stored in the Index register of a cell in memory.
				<br>
				To specify the indexed addressing mode, you just have to write <code>address, I</code>.
				<code class="anc16">
					STA 0x34FE, I
				</code>
			</li>
			<li>
				<strong>Relative</strong>: the argument is a byte that, added with the value stored in the Prgram
				Counter, resolves an address.
				<br>
				The relative addressing mode is specified putting a <code>*</code> before the argument.
				<code class="anc16">
					JNC *0b110
				</code>
			</li>
			<li>
				<strong>Relative with J</strong>: similar to Relative, but with no argument, the value added to the
				Prgram Counter is stored in J.
				<br>
				The relative addressing mode is specified putting a <code>*J</code>. Example:
				<code class="anc16">
					JOC *J
				</code>
			</li>
			<li>
				<strong>Indirect</strong>: the argument is 16-bit long and is and address of a cell that store another
				address used in this addressing mode.
				<br>
				The indirect addressing mode is specified putting the address in two brackets. Example:
				<code class="anc16">
					CMBH (0x40A4)
				</code>
			</li>
			<li>
				<strong>Indirect indexed</strong>: as indirect, but is added the value stored in I (as a signed integer)
				to the final address.
				<br>
				Like in the indirect you have to write <code>(address), I</code>. Example:
				<code class="anc16">
					ANB (0o554), I
				</code>
			</li>
			<li>
				<strong>Implied</strong> you just write the instruction.
				<br>
				Example:
				<code class="anc16">
					SYS
				</code>
			</li>
			<li>
				<strong>Immediate</strong>: when the argument is the operand
				<br>
				The immediate addressing mode is specified putting a <code>#</code> before the argument:
				<code class="anc16">
					LDA # 0xFF00
				</code>
			</li>
			<li>
				<strong>Zero page</strong>: the argument is a byte that specify a cell in the first page of the memory.
				<br>
				The zero page addressing mode is specified putting a <code>%</code> before the address. Example:
				<code class="anc16">
					ADA % 0x4F
				</code>
			</li>
			<li>
				<strong>Zero page indexed</strong>: like the zero page addressing mode, but adding the value stored in I
				as an unsigned integer.
				<br>
				The zero page indexed addressing mode is specified putting a <code>%</code> before the address and
				<code>, I</code> after. Example:
				<code class="anc16">
					SUB % 0xFF, I	; the sum can refer to an address out of the zero page
				</code>
			</li>
			<li>
				<strong>Registers</strong>: the value is stored in a register, these instructions takes no arguments,
				the register is specified in the opcode. Example:
				<br>
				<code class="anc16">
					SHL A<br>
					ADA B<br>
					ORA I<br>
					PSH AH
				</code>
			</li>
		</ul>
		<h2>Directives and predefined instructions</h2>
		<p>
			A directive is command to the preprocessor of the assembler that tells how the assembler should dehave.
			A predefined instruction is not a CPU instruction but is an instruction composed of multiple instructions,
			an example: <code class="anc16">CALL 0x2FFF</code>, the call instruction.
		</p>
		<ul>
			<li>
				<strong>Origin directive</strong>: this tells to the assembler the starting address. Example, if you are
				writing the firmware you know that the ROM starts from <code>xFE00</code> so you will write:
				<code class="anc16">
					ORG 0xFE00
				</code>
			</li>
			<li>
				<strong>Use stdcall directive</strong>: this tells how a routine should be called using <code
					class="anc16">CALL</code>. Usually is putted at the beginning:
				<code class="anc16">
					USE STDCALL
				</code>
			</li>
			<li>
				<strong>Use syslib directive</strong>: this tells to the assembler that you may call a routine defined
				in the system library:
				<code class="anc16">
					USE SYSLIB
				</code>
			</li>
			<li>
				<strong>Use as directive</strong>: is the equivalent <code>#define</code> in C/C++.
				<code class="anc16">
					USE six AS 6
				</code>
			</li>
			<li>
				<strong>Import directive</strong>: is used to import a library
				<code class="anc16">
					IMPORT math
				</code>
			</li>
			<li>
				<strong>Byte directive</strong>: is used to specify that the next literal value is 8-bit long. This
				directive is often used to define a byte in memory.
				<code class="anc16">
					LDAH BYTE # 23
				</code>
			</li>
			<li>
				<strong>Word directive</strong>: is used to specify that the next literal value is 16-bit long. This
				directive is often used to define a word in memory.
				<code class="anc16">
					LDA WORD # 23
				</code>
			</li>
			<li>
				<strong>Reserve</strong>: is used to reserve n bytes in memory
				<code class="anc16">
					RESERVE 10 ; reserve 10 bytes
				</code>
			</li>
			<li>
				<strong>Size of</strong>: is used to specify the size of a label
				<code class="anc16">
					<br>
					hello: "hello, world!"<br>
					_code:<br>
					&emsp;&emsp;LDA # SIZEOF hello
				</code>
			</li>
		</ul>
		<h2>Macros</h2>
		<p>
			Macros are predefined codes
		</p>
		<ul>
			<li>
				<strong>Call</strong>: this allows you to call a routine simply using the label name
				<code class="anc16">
					CALL addRoutine
				</code>
			</li>
			<li>
				<strong>Syscall</strong>: this allows you to make a system call
				<code class="anc16">
					SYSCALL print
				</code>
			</li>
		</ul>
		<h2>Labels</h2>
		<p>
			Are used to assign a symbol to an address to make coding easier. Example:
			<br>
			<code class="anc16">
				addFunction:<br>
				&emsp;&emsp;ADA B<br>
				&emsp;&emsp;RET<br>
				_code:<br>
				&emsp;&emsp;LDA #12<br>
				&emsp;&emsp;LDB #29<br>
				&emsp;&emsp;CALL addFunction<br>
			</code>
			There is one special label called <code class="anc16">_code:</code>, this is the entry point of the program.
			<br>
			Every routine must begin with a label and everything under the label must be indented, like in Python.
		</p>
		<h2>Examples</h2>
		<p>Fibonacci sequence</p>
		<pre class="anc16 readonlyeditor">
USE STDCALL
_code:
	LDA 0
	LDB 1
	CALL fibonacci

fibonacci:
	CMPB #1000	; compare if B is > than 1000
	JCC *3		; if not, jump 3 bytes ahead
	RET		; else return from routine
	STB switchMemory ; save B
	ADB A		; B = B + A
	LDA switchMemory ; A = last status of B
	CALL fibonacci

switchMemory: 
	WORD 0
		</pre>
	</main>
	<footer>
		<p>
			Author: Ancona Simone
			<br>
			Last update: 18/03/2023 (DD/MM/YYYY)
		</p>
	</footer>
</body>

</html>