Idee per la versione 2:Architettura.	Usare una MMT (Memory Mapping Table), simile ai registri MLI e MHI ma anche per IO e magari altro	ISA più coerente (JSP non è definito ad esempio, alcune Transfer non sono biunivoci)	Aumentare la memoria	Stupidata di usare due bus diversi da 16 bit l'uno (circa) (totale 32 bit) per riuscire ad indirizzare solo 132KB (si riuscirebbero ad indirizzare 4GB)	Più operative system oriented	Forse più IRQ furbi (tipo differenziati da device)	Rimuovere la zero page, non serve! Ho un bas dati a 16 bit	Unico bus degli indirizzi, sia per IO che Internal Memory che Internal ROM, uso il control bus per dire External / Internal	Address bus a 24 bit usando 8 bit per indicare la page?	Usare la video memory interna	Mettere la ROM partendo da 0, non ultimi addresses (FE00 - FFFF)	Rimuove il System stack?	Assembly:	Usare gli IF come preprocessore, tipo IF 2NZ (se è usata la versione senza zero page allora..)	Usare USE anche senza AS, come #define in C/C++	Usare $ per tenere conto dell'indirizzo attuale	Usare SIZEOF come direttiva (o OFFSET, si vedrà dopo, ma credo già standard SIZEOF, OFFSET lo userò per altro) che dice la lunghezza in byte dato un label, tipo SIZEOF _code	Magari cambiare i nomi ai JUMP IF (tipo invece che JZS usare JEQ jump if equal)	Dare la possibilità di creare una propria CALL proc usando tipo DEFINE CALL	Usare i label non con absolute addressing mode (ove possibile)	Differenziare CALL e SYSCALL	Direttiva ALLOC oppure RESERV x (poi si vedrà per il nome) per allocare x bytes, esempio:		msg:			"ciao" ALLOC 10				Assemblato viene		x63 x69 x61 x6F x00 x00 x00 x00		x00 x00 x00 x00 x00 x00	Direttiva ADDR che dato un label, "restituisce" una WORD che indica l'indirizzo assoluto di quella label	Dopo BYTE o WORD, la possibilità di definire anche altri numeri, prima non potevi fare BYTE 1, 2, 3, 4, aggiungere la possibilità di farlo